<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>KidEdu Checkers</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f172a;
      --panel2:#111a2e;
      --text:#e6e9ef;
      --muted:#9aa4bf;
      --chip:#1f2a44;
      --chipB:#2f3b5f;

      --board:#b89b6a;
      --light:#f3e9d2;
      --dark:#c9b28a;

      --accent:#32aaca;
      --danger:#e74c3c;
      --blue:#2e86de;
    }

    html, body { height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      min-height:100vh;
      min-height:100dvh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:14px;
      box-sizing:border-box;
    }

    .wrap{
      width:min(980px, 100%);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.10);
      border-radius:18px;
      box-shadow:0 20px 80px rgba(0,0,0,.45);
      overflow:hidden;
    }

    .topbar{
      display:flex;
      gap:10px;
      align-items:center;
      padding:12px 12px;
      background:rgba(255,255,255,.04);
      border-bottom:1px solid rgba(255,255,255,.10);
      flex-wrap:wrap;
    }
    .title{ font-weight:900; letter-spacing:.3px; }
    .pill{
      appearance:none;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:8px 10px;
      border-radius:12px;
      font-weight:800;
      cursor:pointer;
    }
    select.pill{ cursor:pointer; }
    .note{ margin-left:auto; color:var(--muted); font-weight:800; }

    .main{
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:12px;
      padding:12px;
    }
    @media (max-width: 860px){
      .main{ grid-template-columns: 1fr; }
      .note{ margin-left:0; }
    }

    .boardWrap{
      display:flex;
      align-items:center;
      justify-content:center;
      padding:8px 6px 12px;
    }

    .board{
      --b: min(92vw, 520px);
      width: var(--b);
      height: var(--b);
      background: var(--board);
      border-radius: 16px;
      padding: 10px;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      gap:6px;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.18);

      /* iOS-friendly tap behavior */
      touch-action: manipulation;
      -webkit-user-select:none;
      user-select:none;
      -webkit-touch-callout: none;
    }

    .sq{
      border:0;
      padding:0;
      border-radius:12px;
      position:relative;
      cursor:pointer;
      background:transparent;
      -webkit-tap-highlight-color: transparent;
    }
    .sq.light{ background: rgba(255,255,255,.12); }
    .sq.dark{ background: rgba(0,0,0,.08); }

    .sq.sel{ outline: 3px solid rgba(255,255,255,.25); outline-offset: 1px; }
    .sq.move{ box-shadow: inset 0 0 0 3px rgba(50,170,202,0.60); }
    .sq.cap{ box-shadow: inset 0 0 0 3px rgba(231,76,60,0.60); }

    .piece{
      width: 74%;
      height: 74%;
      border-radius: 999px;
      position:absolute;
      left:50%; top:50%;
      transform: translate(-50%,-50%);
      box-shadow: 0 10px 20px rgba(0,0,0,.18), inset 0 0 0 1px rgba(255,255,255,.12);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;

      /* IMPORTANT: allow taps to hit the square button reliably on iOS */
      pointer-events: none;
    }
    .piece.red{ background: linear-gradient(180deg, #ff6a5a, var(--danger)); }
    .piece.blue{ background: linear-gradient(180deg, #58a6ff, var(--blue)); }
    .piece.king{ box-shadow: 0 10px 20px rgba(0,0,0,.18), inset 0 0 0 3px rgba(255,255,255,.28); }
    .kingMark{ font-size:20px; color: rgba(255,255,255,.92); text-shadow:0 2px 8px rgba(0,0,0,.45); }

    .side{
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 16px;
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height: 220px;
    }
    .status{ font-weight:900; font-size:16px; }
    .hint{ color:var(--muted); font-weight:700; }
    .log{
      flex:1;
      overflow:auto;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 12px;
      padding: 10px;
      font-size: 13px;
      color: rgba(255,255,255,.85);
    }
    .log div{ margin-bottom:8px; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">Checkers</div>
      <button class="pill" id="btnNew" type="button">New game</button>

      <select class="pill" id="difficulty" aria-label="Difficulty">
        <option value="easy">Easy ðŸ™‚</option>
        <option value="med" selected>Medium ðŸ¤”</option>
        <option value="hard">Hard ðŸ˜ˆ</option>
      </select>

      <div class="note" id="scoreline">â€”</div>
    </div>

    <div class="main">
      <div class="boardWrap">
        <div class="board" id="board" aria-label="Checkers board"></div>
      </div>

      <div class="side">
        <div class="status" id="status">â€”</div>
        <div class="hint" id="hint">â€”</div>
        <div class="log" id="log"></div>
        <div class="hint">Rules: captures are mandatory. Kings show a â˜….</div>
      </div>
    </div>
  </div>

  <script>
  /* KidEdu Checkers â€” self-contained, iOS-safe input */
  (() => {
    const $ = (id) => document.getElementById(id);

    const boardEl = $("board");
    const btnNew = $("btnNew");
    const difficultySel = $("difficulty");
    const statusEl = $("status");
    const hintEl = $("hint");
    const logEl = $("log");
    const scoreEl = $("scoreline");

    const EMPTY = 0;
    const R = 1, RK = 2;     // Red (human)
    const B = -1, BK = -2;   // Blue (bot)

    // allow parent iframe to set bot via ?bot=easy|med|hard
    const urlBot = new URLSearchParams(location.search).get("bot");
    if (urlBot && difficultySel) difficultySel.value = urlBot;

    const depthByDiff = (diff) => diff === "easy" ? 2 : diff === "hard" ? 6 : 4;

    let board = null;
    let turn = R;
    let selected = null;
    let legalMoves = [];
    let mustContinueCapture = null;
    let busy = false;

    function setStatus(t){ if(statusEl) statusEl.textContent = t; }
    function setHint(t){ if(hintEl) hintEl.textContent = t; }
    function logLine(t){
      if(!logEl) return;
      const div = document.createElement("div");
      div.textContent = t;
      logEl.prepend(div);
    }

    function buildBoardDOM(){
      boardEl.innerHTML = "";
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const sq = document.createElement("button");
          sq.type = "button";
          sq.className = "sq " + (((r+c)%2===1) ? "dark":"light");
          sq.dataset.r = String(r);
          sq.dataset.c = String(c);
          boardEl.appendChild(sq);
        }
      }

      // iOS FIX: bind multiple event types so taps always register (especially in iframes)
      const handler = (e) => {
        if (busy) return;

        const target = e.target.closest(".sq");
        if (!target) return;

        // prevent iOS click delay / scroll steals
        if (e.cancelable) e.preventDefault();

        const r = Number(target.dataset.r);
        const c = Number(target.dataset.c);

        if (turn !== R) return;
        handleHumanTap(r, c);
      };

      // Pointer events (desktop/modern)
      boardEl.addEventListener("pointerdown", handler, { passive:false });

      // iOS Safari fallback
      boardEl.addEventListener("touchstart", handler, { passive:false });

      // Old fallback
      boardEl.addEventListener("mousedown", handler, { passive:false });
    }

    function newGame(){
      board = Array.from({length:8}, ()=>Array(8).fill(EMPTY));
      for(let r=0;r<=2;r++){
        for(let c=0;c<8;c++){
          if((r+c)%2===1) board[r][c]=B;
        }
      }
      for(let r=5;r<=7;r++){
        for(let c=0;c<8;c++){
          if((r+c)%2===1) board[r][c]=R;
        }
      }
      turn = R;
      selected = null;
      legalMoves = [];
      mustContinueCapture = null;
      busy = false;
      if(logEl) logEl.textContent = "";
      setStatus("Your turn (Red)");
      setHint("Tap a red piece, then tap a highlighted square.");
      render();
    }

    function getSq(r,c){
      const idx = r*8+c;
      return boardEl.children[idx] || null;
    }

    function render(){
      if(!board) return;
      for(const sq of boardEl.children){
        sq.classList.remove("sel","move","cap");
        sq.innerHTML = "";
      }

      if(selected){
        const s = getSq(selected.r, selected.c);
        if(s) s.classList.add("sel");
        for(const m of legalMoves){
          const d = getSq(m.tr, m.tc);
          if(!d) continue;
          d.classList.add("move");
          if(m.captures.length) d.classList.add("cap");
        }
      }

      let redCount=0, blueCount=0;
      for(let r=0;r<8;r++) for(let c=0;c<8;c++){
        const v = board[r][c];
        if(v===EMPTY) continue;
        const sq = getSq(r,c);
        const p = document.createElement("div");
        p.className = "piece " + (v>0 ? "red":"blue");
        if(Math.abs(v)===2) p.classList.add("king");

        if(v>0) redCount++; else blueCount++;

        if(Math.abs(v)===2){
          const k = document.createElement("div");
          k.className = "kingMark";
          k.textContent = "â˜…";
          p.appendChild(k);
        }
        sq.appendChild(p);
      }
      if(scoreEl) scoreEl.textContent = `Red: ${redCount}  Blue: ${blueCount}`;
    }

    function handleHumanTap(r,c){
      const v = board[r][c];

      if(mustContinueCapture){
        if(!(selected && selected.r===mustContinueCapture.r && selected.c===mustContinueCapture.c)){
          selected = {...mustContinueCapture};
          legalMoves = movesForPiece(board, R, mustContinueCapture.r, mustContinueCapture.c, true);
        }
      }

      if(v>0){
        if(mustContinueCapture && (r!==mustContinueCapture.r || c!==mustContinueCapture.c)){
          setHint("You must continue capturing with the same piece.");
          return;
        }
        selected = {r,c};
        const anyCaps = allMoves(board, R, true).length>0;
        legalMoves = movesForPiece(board, R, r, c, anyCaps);
        setHint(anyCaps ? "Capture is mandatory: choose a highlighted capture square." : "Choose a highlighted square.");
        render();
        return;
      }

      if(selected){
        const m = legalMoves.find(x => x.tr===r && x.tc===c);
        if(!m) return;

        const from = {...selected};
        applyMove(board, m);
        logLine(`Red: ${pos(from.r,from.c)} â†’ ${pos(m.tr,m.tc)}${m.captures.length?" (capture)":""}`);

        if(m.captures.length){
          const more = movesForPiece(board, R, m.tr, m.tc, true);
          if(more.length){
            mustContinueCapture = {r:m.tr,c:m.tc};
            selected = {r:m.tr,c:m.tc};
            legalMoves = more;
            setHint("Multi-capture! Continue capturing.");
            render();
            return;
          }
        }

        mustContinueCapture = null;
        selected = null;
        legalMoves = [];
        render();

        if(isGameOver(board)) return endGame();

        turn = B;
        setStatus("Bot thinking (Blue)...");
        setHint("â€”");
        busy = true;
        setTimeout(() => { botMove(); busy=false; }, 120);
      }
    }

    function pos(r,c){ return String.fromCharCode(65+c) + (8-r); }
    function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
    function cloneBoard(bd){ return bd.map(row => row.slice()); }
    function willPromote(side, v, tr){
      if(Math.abs(v)===2) return false;
      return (side===R && tr===0) || (side===B && tr===7);
    }

    function movesForPiece(bd, side, r, c, capturesOnly){
      const v = bd[r][c];
      if(v===EMPTY) return [];
      const isKing = Math.abs(v)===2;

      const dirs = [];
      if(side===R || isKing) dirs.push([-1,-1],[-1,+1]);
      if(side===B || isKing) dirs.push([+1,-1],[+1,+1]);

      const captures = [];
      function dfs(brd, cr, cc, pathCaps, pieceVal){
        let found=false;
        const k = Math.abs(pieceVal)===2;

        const dlist = [];
        if(side===R || k) dlist.push([-1,-1],[-1,+1]);
        if(side===B || k) dlist.push([+1,-1],[+1,+1]);

        for(const [dr,dc] of dlist){
          const mr = cr+dr, mc = cc+dc;
          const tr = cr+dr*2, tc = cc+dc*2;
          if(!inBounds(tr,tc) || !inBounds(mr,mc)) continue;
          const mid = brd[mr][mc];
          const dst = brd[tr][tc];
          if(dst!==EMPTY) continue;
          if(side===R && mid>=0) continue;
          if(side===B && mid<=0) continue;
          if(mid===EMPTY) continue;

          found=true;
          const nb = cloneBoard(brd);
          nb[cr][cc]=EMPTY;
          nb[mr][mc]=EMPTY;
          nb[tr][tc]=pieceVal;

          dfs(nb, tr, tc, pathCaps.concat([{r:mr,c:mc}]), pieceVal);
        }

        if(!found && pathCaps.length){
          captures.push({
            fr:r, fc:c, tr:cr, tc:cc,
            captures: pathCaps.slice(),
            promote: willPromote(side, v, cr)
          });
        }
      }
      dfs(bd, r, c, [], v);
      if(captures.length) return captures;
      if(capturesOnly) return [];

      const moves=[];
      for(const [dr,dc] of dirs){
        const tr=r+dr, tc=c+dc;
        if(!inBounds(tr,tc)) continue;
        if(bd[tr][tc]!==EMPTY) continue;
        moves.push({ fr:r, fc:c, tr, tc, captures:[], promote: willPromote(side, v, tr) });
      }
      return moves;
    }

    function allMoves(bd, side, capturesOnly){
      let moves=[];
      for(let r=0;r<8;r++) for(let c=0;c<8;c++){
        const v = bd[r][c];
        if(side===R && v<=0) continue;
        if(side===B && v>=0) continue;
        moves = moves.concat(movesForPiece(bd, side, r, c, capturesOnly));
      }
      if(capturesOnly) return moves.filter(m=>m.captures.length);
      const caps = moves.filter(m=>m.captures.length);
      return caps.length ? caps : moves;
    }

    function applyMove(bd, m){
      const v = bd[m.fr][m.fc];
      bd[m.fr][m.fc] = EMPTY;
      for(const cap of m.captures) bd[cap.r][cap.c]=EMPTY;
      let nv=v;
      if(m.promote) nv = (v>0) ? RK : BK;
      bd[m.tr][m.tc]=nv;
    }

    function evalBoard(bd){
      let score=0;
      for(let r=0;r<8;r++) for(let c=0;c<8;c++){
        const v=bd[r][c];
        if(v===EMPTY) continue;
        const val = (Math.abs(v)===2) ? 3.0 : 1.0;
        if(v<0) score += val + (r*0.02);
        else score -= val + ((7-r)*0.02);
      }
      return score;
    }
    function evalTerminal(side){ return (side===R) ? 9999 : -9999; }

    function minimax(bd, depth, side, alpha, beta){
      if(depth<=0) return evalBoard(bd);
      const moves = allMoves(bd, side, false);
      if(!moves.length) return evalTerminal(side);

      if(side===B){
        let best=-Infinity;
        for(const m of moves){
          const nb=cloneBoard(bd);
          applyMove(nb,m);
          const v=minimax(nb, depth-1, R, alpha, beta);
          best=Math.max(best,v);
          alpha=Math.max(alpha,best);
          if(beta<=alpha) break;
        }
        return best;
      }else{
        let best=Infinity;
        for(const m of moves){
          const nb=cloneBoard(bd);
          applyMove(nb,m);
          const v=minimax(nb, depth-1, B, alpha, beta);
          best=Math.min(best,v);
          beta=Math.min(beta,best);
          if(beta<=alpha) break;
        }
        return best;
      }
    }

    function pickBestMoveFrom(bd, moves, depth){
      let bestMove=moves[0], bestVal=-Infinity;
      for(const m of moves){
        const nb=cloneBoard(bd);
        applyMove(nb,m);
        const val=minimax(nb, depth-1, R, -Infinity, Infinity);
        if(val>bestVal){ bestVal=val; bestMove=m; }
      }
      return bestMove;
    }

    function botMove(){
      const diff = difficultySel ? difficultySel.value : "med";
      const depth = depthByDiff(diff);

      const moves = allMoves(board, B, false);
      if(!moves.length) return endGame();

      const best = pickBestMoveFrom(board, moves, depth);
      applyMove(board, best);
      logLine(`Blue: ${pos(best.fr,best.fc)} â†’ ${pos(best.tr,best.tc)}${best.captures.length?" (capture)":""}`);

      if(best.captures.length){
        let cr=best.tr, cc=best.tc;
        while(true){
          const more = movesForPiece(board, B, cr, cc, true);
          if(!more.length) break;
          const next = pickBestMoveFrom(board, more, Math.max(2, depth-1));
          applyMove(board,next);
          logLine(`Blue: ${pos(next.fr,next.fc)} â†’ ${pos(next.tr,next.tc)} (capture)`);
          cr=next.tr; cc=next.tc;
        }
      }

      render();
      if(isGameOver(board)) return endGame();

      turn=R;
      setStatus("Your turn (Red)");
      setHint("Tap a red piece, then tap a highlighted square.");
    }

    function isGameOver(bd){
      return allMoves(bd, R, false).length===0 || allMoves(bd, B, false).length===0;
    }
    function endGame(){
      const r = allMoves(board, R, false).length;
      const b = allMoves(board, B, false).length;
      if(r===0 && b===0) setStatus("Draw");
      else if(r===0) setStatus("Blue wins");
      else if(b===0) setStatus("Red wins");
      else setStatus("Game over");
      setHint("Tap New game to play again.");
      turn=R; busy=false;
    }

    btnNew && btnNew.addEventListener("click", newGame);
    difficultySel && difficultySel.addEventListener("change", ()=>logLine(`Bot difficulty: ${difficultySel.value}`));

    if(!boardEl) return;
    buildBoardDOM();
    newGame();
  })();
  </script>
</body>
</html>
